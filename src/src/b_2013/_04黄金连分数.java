package src.b_2013;

import java.math.BigDecimal;
import java.math.BigInteger;

/*
标题:黄金连分数
黄金分劃数0.61803...是个无理数,
这个常数十分重要，
在许多工程问题中会出现。
有时需要把这个数字求得很精确。
财于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升 空后就发现了-处人工加工错误,对那样一个庞然大物,
其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!
言归正传，我们如何求得黄金分割数的尽可能精确的值呢?有许多方法。
比较简单的一种是用连分数:
            1
黄金数=  -----------------
                   1
           1 + -----------
                    1
            1 + --------------
                    1
               1 + --------
                    1+······

这个连分数计算的“层数”越多，它的值越接近黄金分割数。
请你利用这一特性， 求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。

小数点后3位的值为: 0. 618
小数点后4位的值为: 0. 6180
小数点后5位的值为: 0. 61803
小数点后7位的值为: 0. 6180340
(注意尾部的0，不能忽略)

你的任务是:写出精确到小数点后100位精度的黄金分割值。

注意:尾数的四舍五入!尾数是0也要保留!

显然答案是一个小数， 其小数点后有100位数字，请通过浏览器直接提交该数字。
注意:不要提交解答过程，或其它辅助说明类的内容。

 */
//1：优化为求裴波那切相邻的比值，到多少项？越多越精确 n/n+1项，n在向上增加，这个比值是稳定的，也就是不变的
//2： double无法表示100为的小数 BigInteger，BigDecimal

//0.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
public class _04黄金连分数 {
    public static void main(String[] args) {
        BigInteger a = BigInteger.ONE;//相邻的两个数
        BigInteger b = BigInteger.ONE;

        //斐波那契数列，前一个数字除以后一个数字的迭代形式
        //n需要一直往上升，直到稳定精确了
        //当n=300或以上之后 结果较为稳定

        for (int i = 3; i < 300; i++) {
            BigInteger t = b; //几率上一次的值
            b = a.add(b);//大数的加法
            a = t; //a记录b的值

        }
        //BigDecimal.ROUND_HALF_UP 四舍五入的方案
        //保留最后110位
        BigDecimal div = new BigDecimal(a, 110).divide(new BigDecimal(b, 110), BigDecimal.ROUND_HALF_UP);
        //截取字符串
        System.out.println(div.toPlainString().substring(0,103));


    }
}
